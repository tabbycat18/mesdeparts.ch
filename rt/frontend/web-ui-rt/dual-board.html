<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>Mes Départs — Dual board</title>
    <link rel="icon" type="image/svg+xml" href="bus-icon-1.svg" />
    <link rel="apple-touch-icon" href="bus-icon-1.png" />
    <link rel="manifest" href="manifest.webmanifest" />
    <meta name="theme-color" content="#01157f" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="application-name" content="Mes Départs" />
    <meta
      name="description"
      content="Double tableau de départs Mes Départs avec horloge sbbUhr, installable en PWA."
    />
    <link rel="preload" href="style.v2026-02-19.css" as="style" />
    <link rel="modulepreload" href="logic.v2026-02-19.js" as="script" />
    <link rel="modulepreload" href="ui.v2026-02-19.js" />
    <link rel="modulepreload" href="state.v2026-02-19.js" />
    <link rel="modulepreload" href="i18n.v2026-02-19.js" />
    <link rel="modulepreload" href="infoBTN.v2026-02-19.js" />
    <link rel="modulepreload" href="favourites.v2026-02-19.js" />
    <script>window.__MD_API_BASE__ = window.__MD_API_BASE__ || "";</script>
    <link rel="modulepreload" href="main.v2026-02-19.js" />
    <link rel="stylesheet" href="style.v2026-02-19.css" />
    <link rel="stylesheet" href="ui/headerControls2.css" />
  </head>
  <body class="dual-body">
    <div class="dual-shell">
      <section class="dual-controls" id="dual-controls">
        <div class="dual-app-bar">
          <div class="dual-bar-left">
            <div class="dual-title">Dual</div>
            <div class="dual-version">v1.7.1</div>
          </div>
          <div class="dual-bar-right">
            <div class="language-switcher language-switcher--inline dual-lang-switcher">
              <label class="sr-only" for="language-select-global">Langue</label>
              <select
                id="language-select-global"
                class="language-select"
                aria-label="Langue"
              ></select>
            </div>
            <div class="dual-controls-divider"></div>
            <button id="swapBtn" class="dual-action" type="button" title="Swap boards">Échanger</button>
            <button id="resetBtn" class="dual-action" type="button" title="Reset to defaults">Réinitialiser</button>
            <button id="hideBtn" class="dual-action" type="button" aria-pressed="false" title="Hide controls">
              Masquer
            </button>
            <button id="fullscreenBtn" class="dual-action" type="button" title="Toggle fullscreen">Plein écran</button>
          </div>
        </div>
        <div id="dual-status" class="dual-status" aria-live="polite"></div>
        <div class="dual-picker-grid">
          <div class="dual-picker" data-side="left" id="picker-mount-left"></div>
          <div class="dual-picker" data-side="right" id="picker-mount-right"></div>
        </div>
      </section>

      <div class="dual-wrap" id="wrapper">
        <iframe class="dual-pane" id="leftPane" title="Board gauche" loading="lazy"></iframe>
        <iframe class="dual-pane" id="rightPane" title="Board droite" loading="lazy"></iframe>
      </div>
    </div>

    <button
      id="showControlsBtn"
      class="show-controls-button"
      type="button"
      aria-label="Afficher les contrôles"
    >
      Afficher les contrôles
    </button>

    <div class="dual-badges-float">
      <div class="dual-version-float" aria-label="Version">v1.7.1</div>
      <button id="info-badge-float" class="dual-info-float" type="button" aria-label="Info" title="Info">INFO</button>
    </div>

    <script type="module">
      import { LANGUAGE_OPTIONS, initI18n, setLanguage, t } from "./i18n.v2026-02-19.js";
      import {
        appState,
        VIEW_MODE_LINE,
        VIEW_MODE_TIME,
        TRAIN_FILTER_ALL,
        TRAIN_FILTER_REGIONAL,
        TRAIN_FILTER_LONG_DISTANCE,
      } from "./state.v2026-02-19.js";
      import { setupInfoButton } from "./infoBTN.v2026-02-19.js";
      import { DualPicker } from "./ui/dualPicker.js";

      const DEFAULT_LANG = initI18n();
      appState.STATION = "Dual board";

      setupInfoButton();

      const params = new URLSearchParams(window.location.search || "");
      const autoFullscreen = params.get("fs") === "1" || params.get("fullscreen") === "1";

      const STORAGE_KEY = "dualBoardPrefs.v2";
      const LEGACY_STORAGE_KEY = "dualBoardUrls.v1";
      const BASE_BOARD_URL = new URL("./", window.location.href);

      const VALID_VIEWS = new Set([
        VIEW_MODE_LINE,
        VIEW_MODE_TIME,
        TRAIN_FILTER_ALL,
        TRAIN_FILTER_REGIONAL,
        TRAIN_FILTER_LONG_DISTANCE,
      ]);
      const VALID_LANGS = new Set(LANGUAGE_OPTIONS.map((opt) => opt.code));
      let currentLanguage = DEFAULT_LANG;
      const urlLang = params.get("lang");
      const normalizedUrlLang = normalizeLang(urlLang);
      if (normalizedUrlLang) currentLanguage = normalizedUrlLang;
      setLanguage(currentLanguage);
      appState.language = currentLanguage;

      const LEFT_DEFAULT = {
        stationName: "Lausanne, motte",
        stationId: "8592082",
        view: VIEW_MODE_LINE,
        hideDeparture: false,
        language: currentLanguage,
      };

      const RIGHT_DEFAULT = {
        stationName: "Lausanne",
        stationId: null,
        view: VIEW_MODE_LINE,
        hideDeparture: false,
        language: currentLanguage,
      };
      const BUS_VIEW_OPTIONS = [
        { v: VIEW_MODE_LINE, label: () => t("viewOptionLine") },
        { v: VIEW_MODE_TIME, label: () => t("viewOptionTime") },
      ];
      const TRAIN_VIEW_OPTIONS = [
        { v: TRAIN_FILTER_ALL, label: () => t("trainFilterAll") },
        { v: TRAIN_FILTER_REGIONAL, label: () => t("trainFilterRegional") },
        { v: TRAIN_FILTER_LONG_DISTANCE, label: () => t("trainFilterLongDistance") },
      ];

      const TRAIN_VIEWS = new Set([
        TRAIN_FILTER_ALL,
        TRAIN_FILTER_REGIONAL,
        TRAIN_FILTER_LONG_DISTANCE,
      ]);

      const BUS_VIEWS = new Set([VIEW_MODE_LINE, VIEW_MODE_TIME]);

      const isTrainView = (val) => TRAIN_VIEWS.has(val);
      const isBusView = (val) => BUS_VIEWS.has(val);

      const normalizeViewByType = (val, isTrain) => {
        const normalized = normalizeView(val);
        if (isTrain) return isTrainView(normalized) ? normalized : TRAIN_FILTER_ALL;
        return isBusView(normalized) ? normalized : VIEW_MODE_LINE;
      };

      const statusEl = document.getElementById("dual-status");
      const controls = document.getElementById("dual-controls");
      const badgesFloat = document.querySelector(".dual-badges-float");
      const wrapper = document.getElementById("wrapper");
      const leftFrame = document.getElementById("leftPane");
      const rightFrame = document.getElementById("rightPane");
      const hideBtn = document.getElementById("hideBtn");
      const showControlsBtn = document.getElementById("showControlsBtn");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const swapBtn = document.getElementById("swapBtn");
      const resetBtn = document.getElementById("resetBtn");
      const languageSelect = document.getElementById("language-select-global");

      const sideLabel = (side) => (side === "right" ? t("dualSideRight") : t("dualSideLeft"));

      function setStatus(msg, state = "info") {
        if (!statusEl) return;
        statusEl.textContent = msg || "";
        statusEl.dataset.state = state;
      }

      function populateLanguageSelect() {
        if (!languageSelect) return;
        languageSelect.innerHTML = "";
        LANGUAGE_OPTIONS.forEach((opt) => {
          const option = document.createElement("option");
          option.value = opt.code;
          option.textContent = opt.label;
          languageSelect.appendChild(option);
        });
        languageSelect.value = currentLanguage;
        languageSelect.setAttribute("aria-label", t("languageLabel"));
      }

      function applyDualTranslations() {
        const setText = (el, key) => {
          if (el) el.textContent = t(key);
        };

        setText(document.querySelector(".dual-title"), "dualBoardLabel");
        setText(swapBtn, "dualSwap");
        setText(resetBtn, "dualReset");
        setText(showControlsBtn, "dualShowControls");
        if (showControlsBtn) showControlsBtn.setAttribute("aria-label", t("dualShowControls"));

        /* Update side labels */
        setText(document.getElementById("side-label-left"), "dualSideLeft");
        setText(document.getElementById("side-label-right"), "dualSideRight");

        if (languageSelect) {
          languageSelect.setAttribute("aria-label", t("languageLabel"));
        }
        const langLabel = document.querySelector("label[for='language-select-global']");
        setText(langLabel, "languageLabel");

        ["left", "right"].forEach((side) => {
          const suffix = side === "right" ? "right" : "left";
          setText(document.querySelector(`label[for='station-input-${suffix}']`), "searchStop");

          const favLabelEl = document.querySelector(
            `#favorites-only-toggle-${suffix} span:not([aria-hidden])`,
          );
          setText(favLabelEl, "filterFavoritesOnlyShort");

          const favTitle = document.getElementById(`favorites-popover-title-${suffix}`);
          setText(favTitle, "filterFavoritesTitle");

          const favEmpty = document.getElementById(`favorites-empty-${suffix}`);
          setText(favEmpty, "filterNoFavorites");

          const filtersButtonLabel = document.querySelector(
            `#filters-open-${suffix} span:last-child`,
          );
          setText(filtersButtonLabel, "filterButton");

          const filtersTitle = document.getElementById(`filters-sheet-title-${suffix}`);
          setText(filtersTitle, "filterButton");

          const filterSectionTitle = document.querySelector(
            `#filters-popover-${suffix} .hc2__sectionTitle`,
          );
          setText(filterSectionTitle, "filterDisplay");

          const filterHideLabel = document.querySelector(
            `#filters-popover-${suffix} .hc2__switchLabel`,
          );
          setText(filterHideLabel, "filterHideDepartureShort");

          const filterResetBtn = document.querySelector(`[data-filter-reset='${suffix}']`);
          setText(filterResetBtn, "filterReset");

          const filterApplyBtn = document.querySelector(`[data-filter-apply='${suffix}']`);
          setText(filterApplyBtn, "filterApply");

          const viewLabel = document.querySelector(
            `#view-segment-${suffix}`)?.parentElement?.querySelector(".hc2__rowLabel");
          setText(viewLabel, "filterDisplay");

          const geoBtn = document.getElementById(`station-search-${suffix}`);
          if (geoBtn) {
            const nearLabel = t("nearbyButton");
            geoBtn.setAttribute("aria-label", nearLabel);
            geoBtn.setAttribute("title", nearLabel);
          }

        });
      }

      function applyGlobalLanguage(lang, { reloadFrames = false } = {}) {
        const next = normalizeLang(lang) || currentLanguage || DEFAULT_LANG;
        currentLanguage = next;
        setLanguage(currentLanguage);
        appState.language = currentLanguage;
        appState.STATION = t("dualBoardLabel");
        if (languageSelect && languageSelect.value !== currentLanguage) {
          languageSelect.value = currentLanguage;
        }
        leftPicker?.setLanguage(currentLanguage, { silent: true });
        rightPicker?.setLanguage(currentLanguage, { silent: true });
        applyDualTranslations();
        leftPicker?.refreshLanguageUi();
        rightPicker?.refreshLanguageUi();
        updateControlsVisibility(controls?.classList.contains("is-collapsed"));
        syncFullscreenLabel();
        if (reloadFrames) {
          applyFrames({ updateQuery: true, showStatus: true });
        }
      }

      const isUrlish = (value) => /^https?:\/\//i.test((value || "").trim());

      function sanitizeUrl(url) {
        if (!url) return "";
        try {
          const parsed = new URL(url, window.location.href);
          if (parsed.protocol !== "http:" && parsed.protocol !== "https:") return "";
          return parsed.toString();
        } catch {
          return "";
        }
      }

      function normalizeLang(lang) {
        const raw = (lang || "").toLowerCase().trim();
        if (!raw) return null;
        if (VALID_LANGS.has(raw)) return raw;
        const short = raw.slice(0, 2);
        return VALID_LANGS.has(short) ? short : null;
      }

      function normalizeView(view) {
        const raw = (view || "").toLowerCase();
        return VALID_VIEWS.has(raw) ? raw : null;
      }

      function parseHide(value) {
        if (value === null || value === undefined) return null;
        const raw = String(value).toLowerCase();
        if (["1", "true", "yes", "on"].includes(raw)) return true;
        if (["0", "false", "no", "off"].includes(raw)) return false;
        return null;
      }

      function normalizeState(input, defaults) {
        const base = { ...defaults };
        if (!input) return base;

        if (input.stationName) base.stationName = String(input.stationName).trim();
        if (input.stationId) base.stationId = String(input.stationId).trim();

        const view = normalizeView(input.view);
        if (view) base.view = view;

        const busView = normalizeView(input.busView);
        if (busView) base.busView = busView;

        const trainView = normalizeView(input.trainView);
        if (trainView) base.trainView = trainView;

        const hide = typeof input.hideDeparture === "boolean" ? input.hideDeparture : parseHide(input.hideDeparture);
        if (hide !== null) base.hideDeparture = !!hide;

        const lang = normalizeLang(input.language);
        if (lang) base.language = lang;

        if (input.customUrl) {
          base.customUrl = sanitizeUrl(input.customUrl) || null;
        } else if ("customUrl" in input) {
          base.customUrl = null;
        }

        base.view = normalizeView(base.view) || VIEW_MODE_LINE;
        base.busView = normalizeView(base.busView);
        base.trainView = normalizeView(base.trainView);
        base.hideDeparture = !!base.hideDeparture;
        base.language = normalizeLang(base.language) || defaults.language || DEFAULT_LANG;

        return base;
      }

      function parseBoardUrl(raw) {
        const clean = sanitizeUrl(raw);
        if (!clean) return null;
        let parsed;
        try {
          parsed = new URL(clean);
        } catch {
          return { customUrl: clean };
        }
        const params = parsed.searchParams;
        const stationName = params.get("stationName");
        const stationId = params.get("stationId");
        const view = normalizeView(params.get("view"));
        const hide = parseHide(params.get("hideDeparture"));
        const language = normalizeLang(params.get("lang"));
        const linesParam = params.get("lines");
        const lineFilter = linesParam ? linesParam.split(",").filter(Boolean) : null;
        const isSameApp =
          parsed.origin === window.location.origin || parsed.hostname.includes("mesdeparts");

        const state = {
          stationName: stationName || null,
          stationId: stationId || null,
          view,
          hideDeparture: hide,
          lineFilter,
          language,
        };

        if (!isSameApp) {
          state.customUrl = clean;
        }
        return state;
      }

      function buildBoardUrl(state, defaults = LEFT_DEFAULT) {
        const s = normalizeState(state, defaults || LEFT_DEFAULT);
        if (s.customUrl) return s.customUrl;

        const url = new URL(BASE_BOARD_URL);
        url.search = "";

        if (s.stationName) url.searchParams.set("stationName", s.stationName);
        if (s.stationId) url.searchParams.set("stationId", s.stationId);
        if (s.view && VALID_VIEWS.has(s.view)) url.searchParams.set("view", s.view);
        if (s.hideDeparture) url.searchParams.set("hideDeparture", "1");
        if (s.lineFilter && s.lineFilter.length > 0) url.searchParams.set("lines", s.lineFilter.join(","));
        if (s.language && VALID_LANGS.has(s.language)) url.searchParams.set("lang", s.language);

        return url.toString();
      }

      function debounce(fn, wait = 200) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...args), wait);
        };
      }

      function loadStoredStates() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          return {
            left: normalizeState(parsed.left, LEFT_DEFAULT),
            right: normalizeState(parsed.right, RIGHT_DEFAULT),
          };
        } catch {
          return {};
        }
      }

      function loadLegacyStates() {
        try {
          const raw = localStorage.getItem(LEGACY_STORAGE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          return {
            left: parsed.left ? normalizeState(parseBoardUrl(parsed.left), LEFT_DEFAULT) : null,
            right: parsed.right ? normalizeState(parseBoardUrl(parsed.right), RIGHT_DEFAULT) : null,
          };
        } catch {
          return {};
        }
      }

      function initialStateForSide(side, stored, legacy) {
        const defaults = side === "left" ? LEFT_DEFAULT : RIGHT_DEFAULT;
        const fromUrl = params.get(side);
        if (fromUrl) {
          return normalizeState(parseBoardUrl(fromUrl), defaults);
        }
        const saved = stored[side];
        if (saved) return normalizeState(saved, defaults);
        const legacyVal = legacy[side];
        if (legacyVal) return normalizeState(legacyVal, defaults);
        return { ...defaults };
      }

      const pickers = [];

      async function resolveInputValue(value) {
        if (!value) return null;
        if (isUrlish(value)) {
          return parseBoardUrl(value) || { customUrl: sanitizeUrl(value) };
        }
        if (value.length < 2) return { stationName: value };
        try {
          const list = await fetchStationSuggestions(value);
          const first = Array.isArray(list) ? list[0] : null;
          if (first && first.name) {
            return { stationName: first.name, stationId: first.id };
          }
        } catch {
          // ignore
        }
        return { stationName: value };
      }

      const defaultsWithLanguage = (defaults) => ({ ...defaults, language: currentLanguage });
      const scheduleApplyFrames = debounce(() => applyFrames(), 120);

      const stored = loadStoredStates();
      const legacy = loadLegacyStates();

      const leftPicker = new DualPicker(
        "left",
        LEFT_DEFAULT,
        initialStateForSide("left", stored, legacy),
        () => scheduleApplyFrames(),
      );
      leftPicker.mount(document.getElementById("picker-mount-left"));

      const rightPicker = new DualPicker(
        "right",
        RIGHT_DEFAULT,
        initialStateForSide("right", stored, legacy),
        () => scheduleApplyFrames(),
      );
      rightPicker.mount(document.getElementById("picker-mount-right"));

      pickers.push(leftPicker, rightPicker);

      const handleGlobalClick = (event) => {
        pickers.forEach((p) => p?.handleGlobalClick?.(event));
      };
      const handleGlobalResize = () => {
        pickers.forEach((p) => p?.handleGlobalResize?.());
      };

      document.addEventListener("click", handleGlobalClick);
      window.addEventListener("resize", handleGlobalResize, { passive: true });

      populateLanguageSelect();
      applyGlobalLanguage(currentLanguage, { reloadFrames: false });

      if (languageSelect) {
        languageSelect.addEventListener("change", () => {
          applyGlobalLanguage(languageSelect.value, { reloadFrames: true });
        });
      }

      function saveStates(leftState, rightState) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ left: leftState, right: rightState }));
        } catch {
          // ignore
        }
      }

      let lastAppliedLeftUrl = "";
      let lastAppliedRightUrl = "";

      function applyFrames({ updateQuery = true, showStatus = true } = {}) {
        if (!leftPicker || !rightPicker || !leftFrame || !rightFrame) return false;

        const leftUrl = leftPicker.getUrl();
        const rightUrl = rightPicker.getUrl();
        if (!leftUrl || !rightUrl) {
          if (showStatus) setStatus(t("dualStatusFillBoth"), "error");
          return false;
        }

        const leftChanged = leftUrl !== lastAppliedLeftUrl;
        const rightChanged = rightUrl !== lastAppliedRightUrl;

        if (leftChanged) {
          leftFrame.src = leftUrl;
          lastAppliedLeftUrl = leftUrl;
        }
        if (rightChanged) {
          rightFrame.src = rightUrl;
          lastAppliedRightUrl = rightUrl;
        }

        if (updateQuery && (leftChanged || rightChanged)) {
          const nextParams = new URLSearchParams(window.location.search || "");
          nextParams.set("left", leftUrl);
          nextParams.set("right", rightUrl);
          nextParams.set("lang", currentLanguage);
          const qs = nextParams.toString();
          history.replaceState({}, "", qs ? `${window.location.pathname}?${qs}` : window.location.pathname);
        }

        saveStates(leftPicker.getSerializableState(), rightPicker.getSerializableState());

        return true;
      }

      function tagIframeForDualEmbed(iframe) {
        if (!iframe) return;
        const applyClass = () => {
          try {
            const doc =
              iframe.contentDocument ||
              (iframe.contentWindow ? iframe.contentWindow.document : null);
            if (!doc) return;
            doc.documentElement?.classList.add("dual-embed");
            doc.body?.classList.add("dual-embed");
          } catch {
            // Ignore cross-origin frames
          }
        };
        iframe.addEventListener("load", applyClass);
      }

      tagIframeForDualEmbed(leftFrame);
      tagIframeForDualEmbed(rightFrame);

      function handleBoardStateMessage(event) {
        const data = event.data;
        if (!data || data.type !== "md-board-state") return;
        let side = null;
        if (leftFrame && event.source === leftFrame.contentWindow) side = "left";
        else if (rightFrame && event.source === rightFrame.contentWindow) side = "right";
        if (!side) return;
        const picker = side === "left" ? leftPicker : rightPicker;
        picker.setBoardType(data.isTrain, data.view, data.hideDeparture, { silent: true });
      }

      window.addEventListener("message", handleBoardStateMessage);

      applyFrames({ updateQuery: true, showStatus: false });

      function swapBoards() {
        const leftState = leftPicker.getSerializableState();
        const rightState = rightPicker.getSerializableState();
        leftPicker.applyState(rightState, { silent: true });
        rightPicker.applyState(leftState, { silent: true });
        applyFrames();
        setStatus(t("dualStatusSwapped"));
      }

      if (swapBtn) swapBtn.addEventListener("click", swapBoards);

      if (resetBtn) {
        resetBtn.addEventListener("click", () => {
          leftPicker.applyState(defaultsWithLanguage(LEFT_DEFAULT), { silent: true });
          rightPicker.applyState(defaultsWithLanguage(RIGHT_DEFAULT), { silent: true });
          applyFrames();
          setStatus(t("dualStatusReset"));
        });
      }

      function updateControlsVisibility(collapsed) {
        const bodyEl = document.body;
        if (controls) {
          controls.classList.toggle("is-collapsed", collapsed);
        }
        if (bodyEl) {
          bodyEl.classList.toggle("dual-controls-hidden", collapsed);
        }
        if (hideBtn) {
          const label = collapsed ? t("dualShowControls") : t("dualHideControls");
          hideBtn.setAttribute("aria-pressed", collapsed ? "true" : "false");
          hideBtn.textContent = label;
          hideBtn.setAttribute("aria-label", label);
        }
        if (showControlsBtn) {
          showControlsBtn.textContent = t("dualShowControls");
          showControlsBtn.setAttribute("aria-label", t("dualShowControls"));
        }
      }

      function toggleControls(forceCollapsed) {
        if (!controls) return;
        const collapsed =
          typeof forceCollapsed === "boolean"
            ? forceCollapsed
            : !controls.classList.contains("is-collapsed");
        updateControlsVisibility(collapsed);
      }

      if (hideBtn) {
        hideBtn.addEventListener("click", toggleControls);
      }

      if (showControlsBtn) {
        showControlsBtn.addEventListener("click", () => toggleControls(false));
      }

      function isFullscreen() {
        return !!(document.fullscreenElement || document.webkitFullscreenElement);
      }

      function syncFullscreenLabel() {
        if (!fullscreenBtn) return;
        const key = isFullscreen() ? "dualExitFullscreen" : "dualFullscreen";
        const label = t(key);
        fullscreenBtn.textContent = label;
        fullscreenBtn.setAttribute("aria-label", label);
        document.body?.classList.toggle("is-fullscreen", isFullscreen());
      }

      async function requestFullscreen() {
        const el = document.documentElement;
        const fn =
          el.requestFullscreen ||
          el.webkitRequestFullscreen ||
          el.msRequestFullscreen ||
          el.mozRequestFullScreen;
        if (fn) {
          await fn.call(el);
          return true;
        }
        return false;
      }

      async function exitFullscreen() {
        const fn =
          document.exitFullscreen ||
          document.webkitExitFullscreen ||
          document.msExitFullscreen ||
          document.mozCancelFullScreen;
        if (fn) await fn.call(document);
      }

      if (fullscreenBtn) {
        fullscreenBtn.addEventListener("click", async () => {
          try {
            if (isFullscreen()) {
              await exitFullscreen();
            } else {
              const ok = await requestFullscreen();
              if (!ok) setStatus(t("dualStatusFullscreenUnavailable"), "error");
            }
          } catch {
            setStatus(t("dualStatusFullscreenFailed"), "error");
          } finally {
            syncFullscreenLabel();
          }
        });
      }

      document.addEventListener("fullscreenchange", syncFullscreenLabel);
      document.addEventListener("webkitfullscreenchange", syncFullscreenLabel);
      syncFullscreenLabel();

      if (autoFullscreen) {
        const enterFs = async () => {
          try {
            await requestFullscreen();
          } catch {
            // ignore
          } finally {
            syncFullscreenLabel();
            document.removeEventListener("pointerdown", enterFs);
            document.removeEventListener("keydown", enterFs);
          }
        };
        document.addEventListener("pointerdown", enterFs, { once: true });
        document.addEventListener("keydown", enterFs, { once: true });
        setStatus(t("dualStatusTapFullscreen"));
      }
    </script>
    <script>
      if ("serviceWorker" in navigator) {
        const path = window.location.pathname || "/";
        const isClock = path.startsWith("/clock");
        const allowed =
          path === "/" ||
          path === "/index.html" ||
          path === "/dual-board.html" ||
          path.startsWith("/?") ||
          path.startsWith("/dual-board.html?");

        const registerSW = () => {
          navigator.serviceWorker
            .register("/service-worker.js")
            .catch((err) => {
              console.error("Service worker registration failed", err);
            });
        };

        if (!isClock && allowed) {
          if (document.readyState === "complete" || document.readyState === "interactive") {
            registerSW();
          } else {
            document.addEventListener("DOMContentLoaded", registerSW, { once: true });
          }
        }
      }
    </script>
  </body>
</html>
